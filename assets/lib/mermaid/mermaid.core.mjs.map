{"version":3,"file":"mermaid.core.mjs","sources":["../src/mermaid.ts"],"sourcesContent":["/**\n * Web page integration module for the mermaid framework. It uses the mermaidAPI for mermaid\n * functionality and to render the diagrams to svg code!\n */\nimport dedent from 'ts-dedent';\nimport { MermaidConfig } from './config.type';\nimport { log } from './logger';\nimport utils from './utils';\nimport { mermaidAPI, ParseOptions, RenderResult } from './mermaidAPI';\nimport { registerLazyLoadedDiagrams, loadRegisteredDiagrams } from './diagram-api/detectType';\nimport type { ParseErrorFunction } from './Diagram';\nimport { isDetailedError } from './utils';\nimport type { DetailedError } from './utils';\nimport { ExternalDiagramDefinition } from './diagram-api/types';\nimport { UnknownDiagramError } from './errors';\n\nexport type {\n  MermaidConfig,\n  DetailedError,\n  ExternalDiagramDefinition,\n  ParseErrorFunction,\n  RenderResult,\n  ParseOptions,\n  UnknownDiagramError,\n};\n\nexport interface RunOptions {\n  /**\n   * The query selector to use when finding elements to render. Default: `\".mermaid\"`.\n   */\n  querySelector?: string;\n  /**\n   * The nodes to render. If this is set, `querySelector` will be ignored.\n   */\n  nodes?: ArrayLike<HTMLElement>;\n  /**\n   * A callback to call after each diagram is rendered.\n   */\n  postRenderCallback?: (id: string) => unknown;\n  /**\n   * If `true`, errors will be logged to the console, but not thrown. Default: `false`\n   */\n  suppressErrors?: boolean;\n}\n\nconst handleError = (error: unknown, errors: DetailedError[], parseError?: ParseErrorFunction) => {\n  log.warn(error);\n  if (isDetailedError(error)) {\n    // handle case where error string and hash were\n    // wrapped in object like`const error = { str, hash };`\n    if (parseError) {\n      parseError(error.str, error.hash);\n    }\n    errors.push({ ...error, message: error.str, error });\n  } else {\n    // assume it is just error string and pass it on\n    if (parseError) {\n      parseError(error);\n    }\n    if (error instanceof Error) {\n      errors.push({\n        str: error.message,\n        message: error.message,\n        hash: error.name,\n        error,\n      });\n    }\n  }\n};\n\n/**\n * ## run\n *\n * Function that goes through the document to find the chart definitions in there and render them.\n *\n * The function tags the processed attributes with the attribute data-processed and ignores found\n * elements with the attribute already set. This way the init function can be triggered several\n * times.\n *\n * ```mermaid\n * graph LR;\n *  a(Find elements)-->b{Processed}\n *  b-->|Yes|c(Leave element)\n *  b-->|No |d(Transform)\n * ```\n *\n * Renders the mermaid diagrams\n *\n * @param options - Optional runtime configs\n */\nconst run = async function (\n  options: RunOptions = {\n    querySelector: '.mermaid',\n  }\n) {\n  try {\n    await runThrowsErrors(options);\n  } catch (e) {\n    if (isDetailedError(e)) {\n      log.error(e.str);\n    }\n    if (mermaid.parseError) {\n      mermaid.parseError(e as string);\n    }\n    if (!options.suppressErrors) {\n      log.error('Use the suppressErrors option to suppress these errors');\n      throw e;\n    }\n  }\n};\n\nconst runThrowsErrors = async function (\n  { postRenderCallback, querySelector, nodes }: Omit<RunOptions, 'suppressErrors'> = {\n    querySelector: '.mermaid',\n  }\n) {\n  const conf = mermaidAPI.getConfig();\n\n  log.debug(`${!postRenderCallback ? 'No ' : ''}Callback function found`);\n\n  let nodesToProcess: ArrayLike<HTMLElement>;\n  if (nodes) {\n    nodesToProcess = nodes;\n  } else if (querySelector) {\n    nodesToProcess = document.querySelectorAll(querySelector);\n  } else {\n    throw new Error('Nodes and querySelector are both undefined');\n  }\n\n  log.debug(`Found ${nodesToProcess.length} diagrams`);\n  if (conf?.startOnLoad !== undefined) {\n    log.debug('Start On Load: ' + conf?.startOnLoad);\n    mermaidAPI.updateSiteConfig({ startOnLoad: conf?.startOnLoad });\n  }\n\n  // generate the id of the diagram\n  const idGenerator = new utils.initIdGenerator(conf.deterministicIds, conf.deterministicIDSeed);\n\n  let txt: string;\n  const errors: DetailedError[] = [];\n\n  // element is the current div with mermaid class\n  // eslint-disable-next-line unicorn/prefer-spread\n  for (const element of Array.from(nodesToProcess)) {\n    log.info('Rendering diagram: ' + element.id);\n    /*! Check if previously processed */\n    if (element.getAttribute('data-processed')) {\n      continue;\n    }\n    element.setAttribute('data-processed', 'true');\n\n    const id = `mermaid-${idGenerator.next()}`;\n\n    // Fetch the graph definition including tags\n    txt = element.innerHTML;\n\n    // transforms the html to pure text\n    txt = dedent(utils.entityDecode(txt)) // removes indentation, required for YAML parsing\n      .trim()\n      .replace(/<br\\s*\\/?>/gi, '<br/>');\n\n    const init = utils.detectInit(txt);\n    if (init) {\n      log.debug('Detected early reinit: ', init);\n    }\n    try {\n      const { svg, bindFunctions } = await render(id, txt, element);\n      element.innerHTML = svg;\n      if (postRenderCallback) {\n        await postRenderCallback(id);\n      }\n      if (bindFunctions) {\n        bindFunctions(element);\n      }\n    } catch (error) {\n      handleError(error, errors, mermaid.parseError);\n    }\n  }\n  if (errors.length > 0) {\n    // TODO: We should be throwing an error object.\n    throw errors[0];\n  }\n};\n\n/**\n * Used to set configurations for mermaid.\n * This function should be called before the run function.\n * @param config - Configuration object for mermaid.\n */\n\nconst initialize = function (config: MermaidConfig) {\n  mermaidAPI.initialize(config);\n};\n\n/**\n * ## init\n *\n * @deprecated Use {@link initialize} and {@link run} instead.\n *\n * Renders the mermaid diagrams\n *\n * @param config - **Deprecated**, please set configuration in {@link initialize}.\n * @param nodes - **Default**: `.mermaid`. One of the following:\n * - A DOM Node\n * - An array of DOM nodes (as would come from a jQuery selector)\n * - A W3C selector, a la `.mermaid`\n * @param callback - Called once for each rendered diagram's id.\n */\nconst init = async function (\n  config?: MermaidConfig,\n  nodes?: string | HTMLElement | NodeListOf<HTMLElement>,\n  callback?: (id: string) => unknown\n) {\n  log.warn('mermaid.init is deprecated. Please use run instead.');\n  if (config) {\n    initialize(config);\n  }\n  const runOptions: RunOptions = { postRenderCallback: callback, querySelector: '.mermaid' };\n  if (typeof nodes === 'string') {\n    runOptions.querySelector = nodes;\n  } else if (nodes) {\n    if (nodes instanceof HTMLElement) {\n      runOptions.nodes = [nodes];\n    } else {\n      runOptions.nodes = nodes;\n    }\n  }\n  await run(runOptions);\n};\n\n/**\n * Used to register external diagram types.\n * @param diagrams - Array of {@link ExternalDiagramDefinition}.\n * @param opts - If opts.lazyLoad is false, the diagrams will be loaded immediately.\n */\nconst registerExternalDiagrams = async (\n  diagrams: ExternalDiagramDefinition[],\n  {\n    lazyLoad = true,\n  }: {\n    lazyLoad?: boolean;\n  } = {}\n) => {\n  registerLazyLoadedDiagrams(...diagrams);\n  if (lazyLoad === false) {\n    await loadRegisteredDiagrams();\n  }\n};\n\n/**\n * ##contentLoaded Callback function that is called when page is loaded. This functions fetches\n * configuration for mermaid rendering and calls init for rendering the mermaid diagrams on the\n * page.\n */\nconst contentLoaded = function () {\n  if (mermaid.startOnLoad) {\n    const { startOnLoad } = mermaidAPI.getConfig();\n    if (startOnLoad) {\n      mermaid.run().catch((err) => log.error('Mermaid failed to initialize', err));\n    }\n  }\n};\n\nif (typeof document !== 'undefined') {\n  /*!\n   * Wait for document loaded before starting the execution\n   */\n  window.addEventListener('load', contentLoaded, false);\n}\n\n/**\n * ## setParseErrorHandler  Alternative to directly setting parseError using:\n *\n * ```js\n * mermaid.parseError = function(err,hash){=\n *   forExampleDisplayErrorInGui(err);  // do something with the error\n * };\n * ```\n *\n * This is provided for environments where the mermaid object can't directly have a new member added\n * to it (eg. dart interop wrapper). (Initially there is no parseError member of mermaid).\n *\n * @param parseErrorHandler - New parseError() callback.\n */\nconst setParseErrorHandler = function (parseErrorHandler: (err: any, hash: any) => void) {\n  mermaid.parseError = parseErrorHandler;\n};\n\nconst executionQueue: (() => Promise<unknown>)[] = [];\nlet executionQueueRunning = false;\nconst executeQueue = async () => {\n  if (executionQueueRunning) {\n    return;\n  }\n  executionQueueRunning = true;\n  while (executionQueue.length > 0) {\n    const f = executionQueue.shift();\n    if (f) {\n      try {\n        await f();\n      } catch (e) {\n        log.error('Error executing queue', e);\n      }\n    }\n  }\n  executionQueueRunning = false;\n};\n\n/**\n * Parse the text and validate the syntax.\n * @param text - The mermaid diagram definition.\n * @param parseOptions - Options for parsing.\n * @returns true if the diagram is valid, false otherwise if parseOptions.suppressErrors is true.\n * @throws Error if the diagram is invalid and parseOptions.suppressErrors is false.\n */\nconst parse = async (text: string, parseOptions?: ParseOptions): Promise<boolean | void> => {\n  return new Promise((resolve, reject) => {\n    // This promise will resolve when the render call is done.\n    // It will be queued first and will be executed when it is first in line\n    const performCall = () =>\n      new Promise((res, rej) => {\n        mermaidAPI.parse(text, parseOptions).then(\n          (r) => {\n            // This resolves for the promise for the queue handling\n            res(r);\n            // This fulfills the promise sent to the value back to the original caller\n            resolve(r);\n          },\n          (e) => {\n            log.error('Error parsing', e);\n            mermaid.parseError?.(e);\n            rej(e);\n            reject(e);\n          }\n        );\n      });\n    executionQueue.push(performCall);\n    executeQueue().catch(reject);\n  });\n};\n\n/**\n * Function that renders an svg with a graph from a chart definition. Usage example below.\n *\n * ```javascript\n *  element = document.querySelector('#graphDiv');\n *  const graphDefinition = 'graph TB\\na-->b';\n *  const { svg, bindFunctions } = await mermaid.render('graphDiv', graphDefinition);\n *  element.innerHTML = svg;\n *  bindFunctions?.(element);\n * ```\n *\n * @remarks\n * Multiple calls to this function will be enqueued to run serially.\n *\n * @param id - The id for the SVG element (the element to be rendered)\n * @param text - The text for the graph definition\n * @param container - HTML element where the svg will be inserted. (Is usually element with the .mermaid class)\n *   If no svgContainingElement is provided then the SVG element will be appended to the body.\n *    Selector to element in which a div with the graph temporarily will be\n *   inserted. If one is provided a hidden div will be inserted in the body of the page instead. The\n *   element will be removed when rendering is completed.\n * @returns Returns the SVG Definition and BindFunctions.\n */\nconst render = (id: string, text: string, container?: Element): Promise<RenderResult> => {\n  return new Promise((resolve, reject) => {\n    // This promise will resolve when the mermaidAPI.render call is done.\n    // It will be queued first and will be executed when it is first in line\n    const performCall = () =>\n      new Promise((res, rej) => {\n        mermaidAPI.render(id, text, container).then(\n          (r) => {\n            // This resolves for the promise for the queue handling\n            res(r);\n            // This fulfills the promise sent to the value back to the original caller\n            resolve(r);\n          },\n          (e) => {\n            log.error('Error parsing', e);\n            mermaid.parseError?.(e);\n            rej(e);\n            reject(e);\n          }\n        );\n      });\n    executionQueue.push(performCall);\n    executeQueue().catch(reject);\n  });\n};\n\nconst mermaid: {\n  startOnLoad: boolean;\n  parseError?: ParseErrorFunction;\n  mermaidAPI: typeof mermaidAPI;\n  parse: typeof parse;\n  render: typeof render;\n  init: typeof init;\n  run: typeof run;\n  registerExternalDiagrams: typeof registerExternalDiagrams;\n  initialize: typeof initialize;\n  contentLoaded: typeof contentLoaded;\n  setParseErrorHandler: typeof setParseErrorHandler;\n} = {\n  startOnLoad: true,\n  mermaidAPI,\n  parse,\n  render,\n  init,\n  run,\n  registerExternalDiagrams,\n  initialize,\n  parseError: undefined,\n  contentLoaded,\n  setParseErrorHandler,\n};\n\nexport default mermaid;\n"],"names":["init"],"mappings":"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"}